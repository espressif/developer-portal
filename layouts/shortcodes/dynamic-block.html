{{/*
Shortcode: dynamic-block
------------------------

This shortcode allows you to inject frequently changing content from a JSON file
into your Hugo pages. It is designed for cases where some parts of a page (such as
status, last update timestamps, or feature lists) need to be updated often without
rebuilding the entire site.

See also https://developer.espressif.com/pages/contribution-guide/dynamic-content/

Usage example

  {{< dynamic-block contentPath="persist/path-to/file.json" jsonKey="timestamp" >}}

Arguments

- contentPath (string)
  Path to the JSON file relative to the site base URL (e.g. "persist/status.json").
  In production, JSON must be served from https://developer.espressif.com/persist/...

- jsonKey (string)
  The key within the JSON object whose value will be injected into the page.
  The content can be plain text, Markdown, or a special field.

Special field handling

- jsonKey = "timestamp"
  If the key is `"timestamp"`, the shortcode expects an ISO8601 date/time string.
  It is automatically converted into a localized, human-readable format:
  `DD Mon YYYY, HH:MM AM/PM` (using the en-GB locale).

- jsonKey containing "list_simple"
  If the key name includes "list_simple", the shortcode expects an array of strings representing a Markdown list.
  The array is automatically joined into a proper Markdown list before rendering.
  Example:
  {
    "feature_list_simple": [
      "- Supported SDKs",
      "  - ✅ [ESP-IDF](https://github.com/espressif/esp-idf/)",
      "  - ⏳ SDK 2"
    ]
  }

- jsonKey containing "table_simple"
  If the key name includes "table_simple", the shortcode expects an array of CSV-style strings representing table rows.
  Each string is converted into a Markdown table row before rendering.
  Example:
  {
    "periph_support_table_simple": [
      "Peripheral,ESP32",
      ":---,:---:",
      "UART,✅",
      "LCD,❌"
    ]
  }

Other keys

- Any other key is assumed to contain Markdown content.
  The Markdown is rendered to HTML before being injected.

Error handling

If the JSON file cannot be fetched or the key is not found, the shortcode will display
an error message instead of the content.
*/}}

{{/*
Toggle for local testing: set to true to load JSON locally from contentPath
(relative to your index.md location).
Leave false (default) to resolve via .Site.BaseURL (web mode).
*/}}
{{ $localMode := true }}  <!-- change to true for local -->


{{ $uniqueID := .Get "jsonKey" | urlize }} <!-- Generate a unique ID -->
<span id="content-{{ $uniqueID }}">Loading...</span>

{{ $contentPath := .Get "contentPath" }}
{{ $jsonKey := .Get "jsonKey" }}

{{/* Only build $fullURL in web mode */}}
{{ $fullURL := "" }}
{{ if not $localMode }}
  {{ $fullURL = printf "%s%s" .Site.BaseURL $contentPath }}
{{ end }}

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const url = '{{ if $localMode }}{{ $contentPath }}{{ else }}{{ $fullURL }}{{ end }}';
    const jsonKey = '{{ $jsonKey }}';
    const uniqueID = '{{ $uniqueID }}';

    fetch(url) // Fetch the JSON file
      .then(response => {
        if (!response.ok) {
          throw new Error('Error fetching the JSON data');
        }
        return response.json();
      })
      .then(data => {
        if (!data[jsonKey]) {
          throw new Error(`Key "${jsonKey}" not found in the JSON data`);
        }

        let content;
        if (jsonKey === "timestamp") {
          // Convert ISO8601 time to desired local time format
          const isoTime = data[jsonKey];
          const options = { day: 'numeric', month: 'short', year: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true };
          content = new Intl.DateTimeFormat('en-GB', options).format(new Date(isoTime));
        } else if (jsonKey.includes("list_simple")) {
          // Join simplified array back into markdown list
          let markdown = data[jsonKey].join("\n");
          content = marked.parse(markdown);
        } else if (jsonKey.includes("table_simple")) {
          // Convert simplified array back into a markdown table
          const rows = data[jsonKey].map(row => `| ${row.replace(/,/g, " | ")} |`);
          const markdown = rows.join("\n");
          content = marked.parse(markdown);
        } else {
          // Extract the value for the key and convert the markdown to HTML
          let markdown = data[jsonKey];
          content = marked.parse(markdown);
        }

        // Inject the content into the unique content span
        document.getElementById(`content-${uniqueID}`).innerHTML = content;
      })
      .catch(error => {
        document.getElementById(`content-${uniqueID}`).textContent = 'Error loading content: ' + error.message;
      });
  });
</script>
